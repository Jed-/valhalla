
// Add alpha channel to a given color INT
|A  = [ | (<< (& $arg1 0xFF) 24) $arg2 ]
|A! = [ | (<< (& $arg1 0xFF) 24) (- $c_white $arg2) ]


// Compresses ARGB color to INT format
// usage: /ARGB>INT #A #R #G #B [ action ]
// INT variables (separate): $a $r $g $b
ARGB>INT = [
	local a r g b
	a = (<< $arg1 24)
	r = (<< $arg2 16)
	g = (<< $arg3  8)
	b =     $arg4
	if (=s $arg5 "") [ + $a $r $g $b ] [ doargs $arg5 ]
]

// Compresses RGB color to INT format
// usage: /RGB>INT #R #G #B [ action ]
// INT variables (separate): $r $g $b
RGB>INT = [
	local r g b
	r = (<< $arg1 16)
	g = (<< $arg2  8)
	b =     $arg3
	if (=s $arg4 "") [ + $a $r $g $b ] [ doargs $arg4 ]
]

// Converts INT color to ARGB format
// usage: /INT>ARGB #INT [ action ]
// ARGB variables: $a $r $g $b
INT>ARGB = [
	local a r g b
	a =    (>> $arg1 24)
	r = (& (>> $arg1 16) 255)
	g = (& (>> $arg1  8) 255)
	b = (&     $arg1     255)
	if (=s $arg2 "") [ concat $a $r $g $b ] [ doargs $arg2 ]
]

// Converts INT color to RGB format
// usage: /INT>RGB #INT [ action ]
// RGB variables: $r $g $b
INT>RGB = [
	local r g b
	r = (& (>> $arg1 16) 255)
	g = (& (>> $arg1  8) 255)
	b = (&     $arg1     255)
	if (=s $arg2 "") [ concat $r $g $b ] [ doargs $arg2 ]
]

INT:TRANS = [
	INT>RGB $arg1 [
		r = (clamp ($arg2 $r $arg3) 0 0xFF)
		g = (clamp ($arg2 $g $arg3) 0 0xFF)
		b = (clamp ($arg2 $b $arg3) 0 0xFF)
		RGB>INT $r $g $b
	]
]

// Converts ARGB color to HEX data
// usage: /ARGB>HEX #A #R #G #B [ action ]
// HEX variables: $hex
ARGB>HEX = [
	local hex
	hex = (tohex (ARGB>INT $arg1 $arg2 $arg3 $arg4) 8)
	if (=s $arg5 "") [ result $hex ] [ doargs $arg5 ]
]

// Converts RGB color to HEX data
// usage: /RGB>HEX #R #G #B [ action ]
// HEX variables: $hex
RGB>HEX = [
	local hex
	hex = (tohex (RGB>INT $arg1 $arg2 $arg3) 6)
	if (=s $arg4 "") [ result $hex ] [ doargs $arg4 ]
]

// Converts RGB color to HSV data
// usage: /RGB>HSV #R #G #B [ action ]
// HSV variables: $h $s $v
RGB>HSV = [
	local r g b mn d h s v
	r  = (divf $arg1 0xFF)
	g  = (divf $arg2 0xFF)
	b  = (divf $arg3 0xFF)
	v  = (maxf $r $g $b)
	mn = (minf $r $g $b)
	if (=f $mn $v) [
		d = 0
		h = 0
		s = 0
	] [
		d = (-f $v $mn)
		s = (divf $d $v)
		h = (floor (casef $v $r [
			*f 60 (modf (divf (-f $g $b) $d) 6)
		] $g [
			*f 60 (+f (divf (-f $b $r) $d) 2)
		] $b [
			*f 60 (+f (divf (-f $r $g) $d) 4)
		]))
	]
	if (=s $arg4 "") [ concat $h $s $v ] [ doargs $arg4 ]
]

// Converts HSV data to RGB format
// usage: /HSV>RGB #H #S #V [ action ]
// RGB variables: $r $g $b
HSV>RGB = [
	local c x m h r g b
	c = (*f $arg3 $arg2)
	x = (*f $c (-f 1 (absf (-f (modf (divf $arg1 60) 2) 1))))
	m = (-f $arg3 $c)
	h = (div $arg1 60)
	r = (round (*f 255 (+f (at [@c @x 0 0 @x @c] $h) $m)))
	g = (round (*f 255 (+f (at [@x @c @c @x 0 0] $h) $m)))
	b = (round (*f 255 (+f (at [0 0 @x @c @c @x] $h) $m)))
	if (=s $arg4 "") [ concat $r $g $b ] [ doargs $arg4 ]
]
