
///////////////////////////////////////////////////////////////////////////////
//  Standard Function Library                                                //
///////////////////////////////////////////////////////////////////////////////

getmaster     = [ listfilter i $arg1 [ismaster    $i] ]
getadmin      = [ listfilter i $arg1 [isadmin     $i] ]
getauth       = [ listfilter i $arg1 [isauth      $i] ]
getspectator  = [ listfilter i $arg1 [isspectator $i] ]
getignored    = [ listfilter i $arg1 [isignored   $i] ]
getbots       = [ listfilter i $arg1 [isai        $i] ]
getdead       = [ listfilter i $arg1 [isdead      $i] ]
getlagged     = [ listfilter i $arg1 [islagged    $i] ]

get!master    = [ listfilter i $arg1 [! (ismaster    $i)] ]
get!admin     = [ listfilter i $arg1 [! (isadmin     $i)] ]
get!auth      = [ listfilter i $arg1 [! (isauth      $i)] ]
get!spectator = [ listfilter i $arg1 [! (isspectator $i)] ]
get!ignored   = [ listfilter i $arg1 [! (isignored   $i)] ]
get!bots      = [ listfilter i $arg1 [! (isai        $i)] ]
get!dead      = [ listfilter i $arg1 [! (isdead      $i)] ]
get!lagged    = [ listfilter i $arg1 [! (islagged    $i)] ]

getblue = [ listfilter i $arg1 [= (getclientteam $i) 1] ]
getred  = [ listfilter i $arg1 [= (getclientteam $i) 2] ]

clamp   = [ max  $arg2 (min  $arg3 $arg1) ]
clampf  = [ maxf $arg2 (minf $arg3 $arg1) ]
clamp=  = [ set $arg1 (max  $arg2 (min  $arg3 $$arg1)) ]
clampf= = [ set $arg1 (maxf $arg2 (minf $arg3 $$arg1)) ]

// truncate decimal points of given value to a specific number
precf = [ substr $arg1 0 (+ (strstr $arg1 .) (+ $arg2 1)) ]

// add string padding to the integer part of a given value
pad0 = [
	arg2 = (- $arg2 (strlen $arg1))
	if $arg3 [] [ arg3 = "0" ]
	if (<= $arg2 0) [ result $arg1 ] [
		concatword (loopconcatword n $arg2 [ result $arg3 ]) $arg1
	]
]

// add string padding to the decimal part of a given value
pad0f = [
	arg2 = (- $arg2 (- (strlen $arg1) (+ (strstr $arg1 .) 1)))
	if $arg3 [] [ arg3 = "0" ]
	if (<= $arg2 0) [ result $arg1 ] [
		concatword $arg1 (loopconcatword n $arg2 [ result $arg3 ])
	]
]

gcd = [ if (= $arg2 0) [ result $arg1 ] [ gcd $arg2 (modf $arg1 $arg2) ] ]
lcm = [ div (* $arg1 $arg2) (gcd $arg1 $arg2) ]

%  = [ round (%f $arg1 $arg2) $arg3 ]
%f = [ *f (divf $arg1 $arg2) (? $arg3 $arg3 100) ]

!f  = [ *f $arg1 -1 ]
--  = [ set $arg1 (-f $$arg1 1) ]
++  = [ set $arg1 (+f $$arg1 1) ]
-=  = [ set $arg1 (-f $$arg1 (? $arg2 $arg2 1)) ]
+=  = [ set $arg1 (+f $$arg1 (? $arg2 $arg2 1)) ]

--c  = [
	set $arg1 (-f $$arg1 1)
	if (> $numargs 1) [ set $arg1 (maxf $$arg1 $arg2) ]
]
++c  = [
	set $arg1 (+f $$arg1 1)
	if (> $numargs 1) [ set $arg1 (minf $$arg1 $arg2) ]
]

// Loops through a given string's characters
// usage: /loopchar  VAR  "string"  [action]
loopchar = [
	loop $arg1 (strlen $arg2) [
		$arg1 = (substr $arg2 $$arg1 1)
		doargs $arg3
	]
]

// Same as looplist, except it loops backwards
looplistrev = [
    looprev $arg1 (listlen $arg2) [
        $arg1 = (at $arg2 $$arg1)
        doargs $arg3
    ]
]

// Same as looplistconcat, except it loops backwards
looplistconcatrev = [
    loopconcatrev $arg1 (listlen $arg2) [
        $arg1 = (at $arg2 $$arg1)
        doargs $arg3
    ]
]

// Shorthand functions that assign return value directly
strsplice=  = [ set $arg1 (strsplice  $$arg1 $arg2 $arg3 $arg4) ]
listsplice= = [ set $arg1 (listsplice $$arg1 $arg2 $arg3 $arg4) ]
listfilter= = [ set $arg1 (listfilter $arg2 $$arg1 $arg3) ]
listdel=    = [ do [
	set $arg1 (listdel $$arg1 @(
		loopconcat n (- $numargs 1) [
			escape $[arg@(+ $n 2)]
		]
	))
] ]

// Subdivide a given list into smaller lists
// usage: /subdivlist  [list items here]  ITEMS-PER-DIV
subdivlist = [
	loopconcat* n $arg2 (ceil (divf (listlen $arg1) $arg2)) [
		escape (sublist $arg1 $n $arg2)
	]
]




///////////////////////////////////////////////////////////////////////////////
//  CoSinusoidal Transition Functions                                        //
///////////////////////////////////////////////////////////////////////////////

// arg1 : TIME INDEX  | The current point in time, modulated by the WAVELENGTH
// arg2 : WAVELENGTH  | Measured in millis, controls the length of a full cycle
// arg3 : Y FORMAT    | Adjusts the Y output to different formats as below:
//   -1 = Goes from 1 to -1 to 1 in a full cycle
//    0 = Goes from 1 to  0 to 1 in a full cycle
//    1 = Same as the previous, but goes negative every other cycle
// The `sinwave` version will have opposite values from `coswave`
coswave = [
	if $arg2 [
		local x y
		x = (modf (*f 180 (divf $arg1 $arg2)) 720)
		if (>= $arg3 0) [
			y = (+f 0.5 (*f 0.5 (cos $x)))
			if (&& $arg3 [<f 180 $x 540]) [ y = (!f $y) ]
			result $y
		] [ cos $x ]
	] [ result 1 ]
]

sinwave = [
	if $arg2 [
		local x y
		x = (modf (*f 180 (divf $arg1 $arg2)) 720)
		if (>= $arg3 0) [
			y = (+f 0.5 (*f 0.5 (sin $x)))
			if (&& $arg3 [<f 180 $x 540]) [ y = (!f $y) ]
			result $y
		] [ sin $x ]
	] [ result 0 ]
]

// cosbounce/sinbounce  VALUE  WAVELENGTH
// multiplies VALUE through the [-1] return value of a cos/sin wave function
// useful for making bouncing elements inside of UIs particularly
cosbounce = [ *f $arg1 (coswave (abs $getmillis) $arg2 -1) ]
sinbounce = [ *f $arg1 (sinwave (abs $getmillis) $arg2 -1) ]

// coswave:INT  INT1  INT2  WAVELENGTH  X-TIME  Y-FORMAT
// if X = 0 will result in game runtime millis use
coswave:INT = [
	if $arg4 [] [ arg4 = $getmillis ]
	arg4 = (coswave (abs $arg4) $arg3 $arg5)
	local r1 g1 b1 r2 g2 b2
	INT>RGB $arg1 [ r1 = $r ; g1 = $g ; b1 = $b ]
	INT>RGB $arg2 [ r2 = $r ; g2 = $g ; b2 = $b ]
	RGB>INT (
		round (+f $r2 (*f (- $r2 $r1) -1 $arg4)) ) (
		round (+f $g2 (*f (- $g2 $g1) -1 $arg4)) ) (
		round (+f $b2 (*f (- $b2 $b1) -1 $arg4))
	)
]

// sinwave:INT  INT1  INT2  WAVELENGTH  X-TIME  Y-FORMAT
// if X = 0 will result in game runtime millis use
sinwave:INT = [
	if $arg4 [] [ arg4 = $getmillis ]
	arg4 = (sinwave (abs $arg4) $arg3 $arg5)
	local r1 g1 b1 r2 g2 b2
	INT>RGB $arg1 [ r1 = $r ; g1 = $g ; b1 = $b ]
	INT>RGB $arg2 [ r2 = $r ; g2 = $g ; b2 = $b ]
	RGB>INT (
		round (+f $r2 (*f (- $r2 $r1) -1 $arg4)) ) (
		round (+f $g2 (*f (- $g2 $g1) -1 $arg4)) ) (
		round (+f $b2 (*f (- $b2 $b1) -1 $arg4))
	)
]

// coswave:RGB  R1 G1 B1  R2 G2 B2  WAVELENGTH  X-TIME  Y-FORMAT
// if X = 0 will result in game runtime millis use
coswave:RGB = [
	if $arg8 [] [ arg8 = $getmillis ]
	arg8 = (coswave (abs $arg8) $arg7 $arg9)
	RGB>INT (
		round (+f $arg4 (*f (- $arg4 $arg1) -1 $arg8)) ) (
		round (+f $arg5 (*f (- $arg5 $arg2) -1 $arg8)) ) (
		round (+f $arg6 (*f (- $arg6 $arg3) -1 $arg8))
	)
]

// sinwave:RGB  R1 G1 B1  R2 G2 B2  WAVELENGTH  X-TIME  Y-FORMAT
// if X = 0 will result in game runtime millis use
sinwave:RGB = [
	if $arg8 [] [ arg8 = $getmillis ]
	arg8 = (sinwave (abs $arg8) $arg7 $arg9)
	RGB>INT (
		round (+f $arg4 (*f (- $arg4 $arg1) -1 $arg8)) ) (
		round (+f $arg5 (*f (- $arg5 $arg2) -1 $arg8)) ) (
		round (+f $arg6 (*f (- $arg6 $arg3) -1 $arg8))
	)
]




///////////////////////////////////////////////////////////////////////////////
//  Gamemode Shortcuts & EoU Functions                                       //
///////////////////////////////////////////////////////////////////////////////

demo = [ stopdemo ; if (mode -1) [ map $arg1 ] ]
complete demo .           dmo

do [
	local n ; n = 0
	looplist m $modelist [
		$m = [ if (mode @n) [ map $arg1 ] ]
		complete $m "data/map" ogz
		n = (+ $n 1)
	]
]
coop = [ if (mode 0) [ map $arg1 ] ]
edit = [ if (mode 0) [ map $arg1 ] ]

complete map  "data/map" ogz // global handle
complete coop "data/map" ogz // legacy handle
complete edit "data/map" ogz // legacy handle

copymapcfg = [
	if (&& $numargs [! $mainmenu]) [
		.cmc_from $arg1
		.cmc_to   (? (> $numargs 1) $arg2 $mapname)
		if (findfile (concatword "data/map/" $.cmc_from ".cfg")) [
			if (findfile (concatword "data/map/" $.cmc_to ".cfg")) [ showui "dialog_copycfg" ] [
				textfocus "#copymapcfg"
				textload (concatword "data/map/" $.cmc_from ".cfg")
				textsave (concatword "data/map/" $.cmc_to   ".cfg")
			]
		] [
			error (format "%1 ^f3: no such map config!" $.cmc_from)
			.cmc_from "" ; .cmc_to ""
		]
	]
]

chatsay     = [ inputcommand $arg1 [say     $commandbuf] "[^f7Chat^f7]"      s ]
chatteamsay = [ inputcommand $arg1 [sayteam $commandbuf] "[^f8Team chat^f7]" s ]
chatexec    = [ inputcommand $arg1 [do      $commandbuf] "[^f4Do^f7]"        s ]

showscoreboard = [
	sleep $arg1 [
		if (|| [uivisible "main"] [isspectator $getclientnum]) [] [
			showui "scoreboard"
		]
	]
]

togglemainmenu = [ || hidetopui [ toggleui "main" ] ]

togglefullcon = [
	fullconsize (? (iskeyheld "LCTRL") 80 40)
	toggleui "fullconsole"
]

togglefullscreen = [
	fullscreen (! $fullscreen)
	if $fullscreen [
		screenw $desktopw
		screenh $desktoph
		gscale $.gscalef
	] [
		screenw $.screenw
		screenh $.screenh
		gscale $.gscalew
	]
]

nextspecmode = [
	if $specmode [
		specmode (mod (+ $specmode 1) 3)
	] [
		specmode (+ (> $getfollow -1) 1)
	]
]

dozoom = [
	if $zoomtoggle [
		zoom (* $zoom -1)
	] [
		zoom 1
		onrelease [ zoom -1 ]
	]
]

notepad = [
	if $numargs [ notepadpath = $arg1 ]
	showui "notepad"
]

// Quickly (un)spec yourself, or someone else given a CN
spec = [
	if $arg1 [] [ arg1 = $getclientnum ]
	spectator (! (isspectator $arg1)) $arg1
]

// Handy shorthand for manually changing server mastermode
mm = [ if $numargs [ mastermode $arg1 ] ]

// Handy shorthand to reload the current map
rm = [ map $mapname ]




///////////////////////////////////////////////////////////////////////////////
//  Player Follow Function                                                   //
///////////////////////////////////////////////////////////////////////////////

followplayer = [
	.followlist (get!spectator $listclients)
	if (&& $editing [listlen $.followlist]) [
		if (< (indexof $.followlist $.followcn) 0) [ .followcn (at $.followlist 0) ]
		if (= $.crosshairsize 0) [
			.crosshairsize $crosshairsize
			crosshairsize 0
			.followplayer 1
		]
		sleep 1 [ goto $.followcn ; followplayer ]
	] [
		crosshairsize $.crosshairsize
		.crosshairsize 0
		.followplayer 0
	]
]

follownext = [
	arg3 = (listlen $.followlist)
	if (&& $.followplayer $arg3) [
		.followcn (+ $arg3 (indexof $.followlist $.followcn) (? (>= $arg1 0) 1 -1))
		.followcn (at $.followlist (mod $.followcn $arg3))
	] arg2
]




///////////////////////////////////////////////////////////////////////////////
//  Misc Useful Functions                                                    //
///////////////////////////////////////////////////////////////////////////////

// Accepts a list of conditions, true statements, and false statements,
// and works through them one at a time, performing an action depending
// on the result of the condition, breaking the loop if one's false.
// Performs additional action at the end depending on loop results.
// usage: /cmd [ [cond1] [true1] [false1] .. ]  [ on-success ]  [ on-fail ]
cmd = [
	arg4 = 0
	looplist3 condition true false $arg1 [
		if (&& [> $arg4 -1] $condition) [
			arg4 = (+ $arg4 1) ; doargs $true
		] [ arg4 = -1 ; doargs $false ]
	]
	if (= (div (listlen $arg1) 3) $arg4) [ doargs $arg2 ] [ doargs $arg3 ]
]




///////////////////////////////////////////////////////////////////////////////
//  Crosshair Definitions -- WIP                                             //
///////////////////////////////////////////////////////////////////////////////

loadcrosshair "data/interface/crosshair/ally.png" 0 // ally
loadcrosshair "data/interface/crosshair/default.png"  1 // normal
loadcrosshair "data/interface/crosshair/default_hit.png" 2 // hit
loadcrosshair "data/interface/crosshair/d.png" // edit




///////////////////////////////////////////////////////////////////////////////
//  Hook Definitions                                                         //
///////////////////////////////////////////////////////////////////////////////

on_kill = []

on_death = [
    if (&& $deathscoreboard $getmode) [
        showscoreboard 950
    ]
]

on_spawn = []

on_connect = [
    music "" 5000
]

on_disconnect = []

on_forcedisconnect = [
    showui "dialog_serverdisconnect"
]

on_mapstart = [
	.scoreboard.update
	if $mapmusic [
        music $mapmusic 0 "music"
	]
	fragQueue = ""
]

on_intermission = [
    showscoreboard 700
    music "intermission" 1500 "music"
]

on_edittoggle = [
	if $editing [
		if $hidehud [] [
			showui "edithud"
			if (! (uivisible "fullconsole")) [ showui "editvars" ]
		]
	] [
		hideui "edithud"
		hideui "editvars"
		hideui "material"
		hideui "texture_browser"
		hideui "mapmodel_browser"
		hideui "geo_prefab"
	]
]

// XXX
on_mainmenutoggle = [
	if $mainmenu [
		hideui "scoreboard"
		music "menu.ogg" 5000
	] [

	]
]

on_killfeed = [
	listsplice= fragQueue (escape $getmillis (
		escape (getclientname $getkillfeedactor) ) (
		escape (getclientname $getkillfeedtarget)
	) $getkillfeedweap $getkillfeedcrit $getkillfeedactor $getkillfeedtarget) 0 0
	if (> (listlen $fragQueue) $uiKillCount) [
		push x (at $fragQueue $uiKillCount) []
			listsplice= fragQueue (escape (
				listsplice $x (- $getmillis $uiKillDecay) 0 1
			)) $uiKillCount 1
		]
	]
]




///////////////////////////////////////////////////////////////////////////////
//  Startup Sanitization & Routines                                          //
///////////////////////////////////////////////////////////////////////////////

if $.followplayer [
	crosshairsize $.crosshairsize
	.crosshairsize 0
	.followplayer 0
]

musicvol $.musicvol
fragQueue = ""
